---
title: "Round Pairing"
author: "ajw"
output:
  html_document:
    css: markdown7.css
---

# Set-up
Set the round that you are pairing.
```{r}
round <- 4
amta <- F
coinTie <- 'heads'
coinR3  <- 'heads'
```

This runs the backing functions, which can be found [here](https://gist.github.com/anniejw6/9cb2d782eb9b7758a653).
```{r,warning = F, message = F}
source('pair_func.R')
```

Read in data from google sheets.
```{r}
teams <- 'https://docs.google.com/spreadsheets/d/1REb82IzLPC3S7n93CntfAaqBETdSCDXoO6DKS9VV0ro/pubhtml?gid=0&single=true'
tab   <- 'https://docs.google.com/spreadsheets/d/1REb82IzLPC3S7n93CntfAaqBETdSCDXoO6DKS9VV0ro/pubhtml?gid=2080568749&single=true'

teams <- readSpreadsheet(teams)
df <- cleanTab(readSpreadsheet(tab))

tab <- data.frame(
  team = df$TEAM,
  side = df[[paste0('R', round - 1, '_SIDE')]],
  wpb  = as.numeric(df[[paste0('R', round - 1, '_RT_WPB')]]),
  pb   = as.numeric(df[[paste0('R', round - 1, '_RT_PB')]]),
  pd   = as.numeric(df[[paste0('R', round - 1, '_RT_PD')]]),
  stringsAsFactors = F
)

tab$rank <- rankWPB(wpb = 'wpb',
                    pb  = 'pb',
                    pd  = 'pd', 
                    dat = tab, 
                    r = round,
                    coinflip = coinTie)
```

`teams` lists out past pairings, which are used to check impermissibles.
```{r, echo = F, results='asis'}
printTab(xtable(head(teams)))
```

`tab` shows the values on which we pair.
```{r, echo = F, results='asis'}
printTab(xtable(head(tab)))
```

# Defining Impermissibles
We store a list of impermissible match-ups, which are 
defined either as teams from the same school or teams that have previously faced one another.
Here's a sample of that list.
```{r, echo = F, results='asis'}
impermiss <- rbind(sameSchool(teams),
                   pastOpp(df, round))
printTab(xtable(head(impermiss)))
```

# Pairing

Now we pair the teams. If the round is side-constrained, we rank and pair by sides. Otherwise, we take all the teams togther.
```{r}
pair <- tab

#if round is side-constrained:
if(round %in% c(2,4)){
  
  #rank sides separately
  pair$side <- ifelse(tab$side == 'P', 'D', 'P')  
  pair <- ddply(pair, .(side), mutate, rank = rank(rank))
  
  #pair highest versus highest
  pair <- pair[order(pair$rank, pair$side), ]
  
} else {
  
  #rank teams together
  pair <- pair[order(pair$rank), ]
  
  #pair 1 vs 2, 3 vs 4, etc
  if(coinR3 == 'heads'){
    pair$side <- rep(c('P', 'D'))
  } else {
    pair$side <- rep(c('D', 'P'))
  }


}

pair$trial <- rep(1:(nrow(pair)/2), each = 2)
```

Here's the pairings, which may or may not include impermissibles.
```{r, echo = F, results='asis'}
printTab(xtable(pairPretty(pair)))
```

# Finding and Resolving Impermissibles

We loop through each row and see whether 
the matchup is in the list of impermissibles we created earlier.
```{r, echo = T, results='asis'}
# Find impermissibles
pair$impermiss <- findImpermiss(pair, impermiss)

# Set value to store swaps
swaps <- data.frame(Team1 = NA, Team2 = NA, final = NA)
```

And then we actually try to resolve them.
```{r impermiss, results = 'asis'}
# If there are no impermissibles,
if(sum(pair$impermiss) == 0){
  
  writeLines('No impermissibles!')
  
} else {
  
  pair$newRank <- pair$rank
  
  # resolve impermissibles
  while (sum(pair$impermiss) > 0){
  
    # Print pairings at start
    writeLines('Current List of Pairings')
    printTab(xtable(addColor(pairPretty(pair))))
    
    # set trial_x = highest trial with impermissible
    trial_x <- pair[pair$trial == pair$trial[min(which(pair$impermiss == T))], ]
    
    # Compare swap distances based on WPB, PB, and PD
    possSwaps <- compareDist(x = trial_x, all = pair, round = round, amta = F)  
    
    repeat{
      
      # Set proposed_swap = minimum distance swap
      proposedSwap <- possSwaps[1, ]
      
      # proposed Swap
      writeLines('Proposed Swap')
      printTab(xtable(proposedSwap))
      
      # If it's allowed
      
      if(!paste(swapList(newSwap = proposedSwap, oldSwap = trial_x), collapse = '') 
         %in% swaps$final){
        break # Move on
      }
      
      # If it's not allowed, remove proposed_swap from possible
      writeLines('Proposed swap is not possible!')
      possSwaps <- possSwaps[-1, ]
    }
    
    #  make proposed_swap
    pair <- makeSwap(newSwap = proposedSwap, old = trial_x, dat = pair)
    
    #  insert proposed_swap in SWAP
    swaps <- insertSwap(newSwap = proposedSwap, oldSwap = trial_x, dat = swaps)
    
    #  set n = number of impermissibles
    pair$impermiss <- findImpermiss(pair, impermiss)
    }
  }
```

# Final Pairings

Here are final pairings, which are resolved for impermissibles.
```{r, echo = F, results = 'asis'}
printTab(xtable(addColor(pairPretty(pair))))
```

