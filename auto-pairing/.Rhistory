stringsAsFactors = F)
return(x)
}
# Read from spreadsheet
readSpreadsheet <- function(url, sheet = 1){
r <- GET(url)
html <- content(r)
sheets <- readHTMLTable(html, header=FALSE, stringsAsFactors=FALSE)
df <- sheets[[sheet]]
dfClean <- function(df){
nms <- t(df[1,])
names(df) <- nms
df <- df[-1,-1]
row.names(df) <- seq(1,nrow(df))
df
}
dfClean(df)
}
cleanTab <- function(dat){
del <- c(paste0('S.', 1:3), '','S', 'CURRENT_WPB', 'CURRENT_RANK', 'CURRENT_BAL', 'CURRENT_CS', 'CURRENT_PD')
df <- dat[, !colnames(dat) %in% del]
df <- subset(df, TEAM != '')
df[df == '#N/A'] <- NA
df[df == 'NA'] <- NA
i <- sapply(df, is.factor)
df[i] <- lapply(df[i], as.character)
return(df)
}
# Create data-frame of impermissible based on same school
sameSchool <- function(df){
teams <- subset(df, University %in% University[duplicated(University)])
x <- ddply(teams, .(University), function(x){
res <- t(combn(x[['Team Name']], 2))
oth <- res[, c(2, 1)]
res <- data.frame(rbind(res, oth))
return(res)
})
x$University <- NULL
colnames(x) <- c('Team1', 'Team2')
return(x)
}
# Create data-frame of impermissible based on past opponents
pastOpp <- function(df, round){
# Opponents up to that round
impermiss <- df[, c('TEAM', paste0('R',1:(round - 1),'_OPP'))]
impermiss <- melt(impermiss, id = 'TEAM')
# Get rid of random variable
impermiss$variable <- NULL
# Subset to rounds that have been paired
impermiss <- subset(impermiss, !is.na(value))
# Clean-up
colnames(impermiss) <- c('Team1', 'Team2')
return(impermiss)
}
### Make Pairs look pretty ###
pairPretty <- function(dat = pair, impermiss = T){
# Order by Trial
dat <- dat[order(dat$trial, dat$side), ]
# Stack P and D
p <- subset(dat, side == 'P')
colnames(p) <- paste0('p_', colnames(p))
d <- subset(dat, side == 'D')
colnames(d) <- paste0('d_', colnames(d))
x <- cbind(p, d)
# Clean up Columns
x <- x[, !grepl('side', colnames(x))]
x <- x[, c('p_trial', 'p_team', 'd_team', 'p_wpb', 'p_pb', 'p_pd', 'p_rank',
'd_wpb', 'd_pb', 'd_pd', 'd_rank')]
colnames(x)[1] <- 'trial'
# Add Impermissibles
if(impermiss == T){
x$impermiss <- p$p_impermiss
}
# Round
i <- grepl('wpb|pb|pd', colnames(x))
x[i] <- lapply(x[i], function(x) round(x, 3))
return(x)
}
# rank teams by WPB, PB, PD, coin-flip
rankWPB <- function(wpb, pb, pd, dat = tab, r = round, coinflip = 'heads'){
if(coinflip == 'heads'){
coinflip <- rank(tab$team)
print('In case of ties, larger team number gets higher rank.')
}else {
coinflip <- -rank(tab$team)
print('In case of ties, lower team number gets higher rank.')
}
wpb <- dat[[wpb]]
pb <- dat[[pb]]
pd <- dat[[pd]]
wpb[is.na(wpb)] <- 0
pb[is.na(pb)] <- 0
pd[is.na(pd)] <- 0
return(rank(-1*as.numeric(
interaction(wpb, pb, pd, coinflip,
drop = TRUE, lex.order = TRUE))))
}
# Calculate distance by WPB, PB, PD
# Returns
compareDist <- function(x = trial_x, all = pair, round = round, amta = F){
# Minor Cleaning
all[is.na(all)] <- 0
x[is.na(x)] <- 0
# Create temporary ranking (after adjustments for impermissibles)
all <- all[order(all$trial, all$side), ]
if(round %% 2 == 0){
all <- ddply(all, .(side), mutate, newRank = rank(trial))
} else {
all$newRank <- 1:nrow(all)
}
x <- merge(x, all[, c('team', 'side', 'newRank')])
# Create all possible matches
calcDist <- function(x, all, sideT, roundNum = round){
x <- subset(x, side == sideT)
if(roundNum %% 2 == 0){
all <- subset(all, side == sideT)
}
if(sideT == 'D'){
cat <-  'Keep P, Swap D'
} else {
cat <- 'Keep D, Swap P'
}
return(
data.frame(
dist_wpb = abs(all$wpb - x$wpb),
dist_pb = abs(all$pb - x$pb),
dist_pd = abs(all$pd - x$pd),
dist_rank = abs(all$newRank - x$newRank),
cat = cat
)
)
}
if(round %% 2 == 0){ # If round is side-constrained
# Compare against teams of the same side
dSwap <- data.frame(p = x$team[x$side == 'P'],
d = all$team[all$side == 'D'])
dSwap <- cbind(dSwap, calcDist(x = x, all = all, sideT = 'D'))
pSwap <- data.frame(p = all$team[all$side == 'P'],
d = x$team[x$side == 'D'])
pSwap <- cbind(pSwap, calcDist(x = x, all = all, sideT = 'P'))
} else {
# Compare against all teams
dSwap <- data.frame(p = x$team[x$side == 'D'],
d = all$team)
dSwap <- cbind(dSwap, calcDist(x = x, all = all, sideT = 'D'))
pSwap <- data.frame(p = all$team[all$side == 'P'],
d = x$team)
pSwap <- cbind(pSwap, calcDist(x = x, all = all, sideT = 'P'))
}
res <- unique(rbind(dSwap, pSwap))
# Get rid of factors
i <- sapply(res, is.factor)
res[i] <- lapply(res[i], as.character)
# Get rid of matches where you're swapping the original ones,
# or where you're matching against the same team.
res <- subset(res, p != d)
res <- subset(res, !paste0(res$p, res$d) %in% c(paste0(x$team, collapse =''),
paste0(rev(x$team), collapse = '')))
# Sort by distance
res <- res[order(res$dist_rank, res$dist_wpb, res$dist_pb, res$dist_pd), ]
res <- subset(res, dist_rank > 0) # This is the no-swap option
return(res)
}
# Function to add metadata after pairing
teamMeta <- function(pair, input, side, round){
pair[[paste0(side, '_team')]] <- as.character(input[, 1])
pair[[paste0(side, '_WPB')]] <- as.numeric(input[, 3])
pair[[paste0(side, '_pb')]] <- as.numeric(input[, 4])
pair[[paste0(side, '_pd')]] <- as.numeric(input[, 5])
if(round %% 2 == 0){
pair[[paste0(side, '_rank')]] <- 1:nrow(pair)
} else {
pair[[paste0(side, '_rank')]] <- as.numeric(input[, 6])
}
return(pair)
}
# Find Impermissibles
findImpermiss <- function(dat = pair, impermissibles = impermiss){
notOkay <- paste0(impermissibles[, 1], impermissibles[, 2])
res <- rep(F, nrow(dat))
for(i in 1:nrow(dat)){
proposedPair <- paste(pair$team[pair$trial == pair$trial[i]], collapse = '')
if(proposedPair %in% notOkay){
res[i] <- T
}
}
return(res)
}
# Make proposed swap
makeSwap <- function(newSwap = proposedSwap, old = trial_x, dat = pair){
swap <- function(swapSide = 'P', dat = dat){
# Get row numbers
oldD <- which(dat$team == old$team[old$side == swapSide])
newD <- which(dat$team == newSwap[[tolower(swapSide)]])
#writeLines('\nOriginal values\n')
#printTab(xtable(dat[c(oldD, newD), ]))
# Make the swap
oldTrial <- dat$trial[oldD]
oldSide <- dat$side[oldD]
newTrial <- dat$trial[newD]
newSide <- dat$side[newD]
dat$trial[c(oldD, newD)] <- c(newTrial, oldTrial)
dat$side[c(oldD, newD)] <- c(newSide, oldSide)
#writeLines('\nNew values\n')
#printTab(xtable(dat[c(oldD, newD), ]))
return(dat)
}
if(newSwap$cat == 'Keep D, Swap P'){
#writeLines(paste('\nSwapping Pros team', old$P_team, 'for', newSwap$p))
side = 'P'
} else {
#writeLines(paste('\nSwapping Def team', old$D_team, 'for', newSwap$d))
side = 'D'
}
return(swap(swapSide = side, dat = dat))
}
# Generate Swap
swapList <- function(newSwap = proposedSwap, oldSwap = trial_x){
if(newSwap$cat == 'Keep P, Swap D'){
neW <- c(team1 = newSwap$d,
team2 = trial_x$team[trial_x$side == 'D'])
} else {
neW <- c(team1 = newSwap$p,
team2 = trial_x$team[trial_x$side == 'P'])
}
return(neW)
}
# Insert Swaps
insertSwap <- function(newSwap = proposedSwap, oldSwap = trial_x, dat = swaps){
x <- swapList(newSwap = proposedSwap, oldSwap = trial_x)
# Create out combinations
news <- data.frame(Team1 = x,
Team2 = rev(x),
final = NA,
stringsAsFactors = F)
# Add to existing
dat <- rbind(dat, news)
# Get rid of NAs
dat <- subset(dat, !is.na(Team1))
# Create concatenation
dat$final <- apply(dat, 1, function(x){
paste0(x[1], x[2])
})
return(dat)
}
compareDist(x = trial_x, all = pair, round = round, amta = F)
pairPretty(pair)
[library(XML)
library(httr)
library(plyr)
library(reshape)
library(knitr)
library(xtable)
# Prints pretty things
printTab <- function(x){
print(x, type = 'html', include.rownames = F,
sanitize.text.function = force,
sanitize.rownames.function = NULL,
sanitize.colnames.function = NULL)
}
# Adds color to impermissibles
addColor <- function(x = pair){
x[x$impermiss == T, ] <- as.data.frame(lapply(x[x$impermiss == T,],
FUN = function(x) {paste0('<span style="color:red">', x, '</span>')}),
stringsAsFactors = F)
return(x)
}
# Read from spreadsheet
readSpreadsheet <- function(url, sheet = 1){
r <- GET(url)
html <- content(r)
sheets <- readHTMLTable(html, header=FALSE, stringsAsFactors=FALSE)
df <- sheets[[sheet]]
dfClean <- function(df){
nms <- t(df[1,])
names(df) <- nms
df <- df[-1,-1]
row.names(df) <- seq(1,nrow(df))
df
}
dfClean(df)
}
cleanTab <- function(dat){
del <- c(paste0('S.', 1:3), '','S', 'CURRENT_WPB', 'CURRENT_RANK', 'CURRENT_BAL', 'CURRENT_CS', 'CURRENT_PD')
df <- dat[, !colnames(dat) %in% del]
df <- subset(df, TEAM != '')
df[df == '#N/A'] <- NA
df[df == 'NA'] <- NA
i <- sapply(df, is.factor)
df[i] <- lapply(df[i], as.character)
return(df)
}
# Create data-frame of impermissible based on same school
sameSchool <- function(df){
teams <- subset(df, University %in% University[duplicated(University)])
x <- ddply(teams, .(University), function(x){
res <- t(combn(x[['Team Name']], 2))
oth <- res[, c(2, 1)]
res <- data.frame(rbind(res, oth))
return(res)
})
x$University <- NULL
colnames(x) <- c('Team1', 'Team2')
return(x)
}
# Create data-frame of impermissible based on past opponents
pastOpp <- function(df, round){
# Opponents up to that round
impermiss <- df[, c('TEAM', paste0('R',1:(round - 1),'_OPP'))]
impermiss <- melt(impermiss, id = 'TEAM')
# Get rid of random variable
impermiss$variable <- NULL
# Subset to rounds that have been paired
impermiss <- subset(impermiss, !is.na(value))
# Clean-up
colnames(impermiss) <- c('Team1', 'Team2')
return(impermiss)
}
### Make Pairs look pretty ###
pairPretty <- function(dat = pair, impermiss = T){
# Order by Trial
dat <- dat[order(dat$trial, dat$side), ]
# Stack P and D
p <- subset(dat, side == 'P')
colnames(p) <- paste0('p_', colnames(p))
d <- subset(dat, side == 'D')
colnames(d) <- paste0('d_', colnames(d))
x <- cbind(p, d)
# Clean up Columns
x <- x[, !grepl('side', colnames(x))]
x <- x[, c('p_trial', 'p_team', 'd_team', 'p_wpb', 'p_pb', 'p_pd', 'p_rank',
'd_wpb', 'd_pb', 'd_pd', 'd_rank')]
colnames(x)[1] <- 'trial'
# Add Impermissibles
if(impermiss == T){
x$impermiss <- p$p_impermiss
}
# Round
i <- grepl('wpb|pb|pd', colnames(x))
x[i] <- lapply(x[i], function(x) round(x, 3))
return(x)
}
# rank teams by WPB, PB, PD, coin-flip
rankWPB <- function(wpb, pb, pd, dat = tab, r = round, coinflip = 'heads'){
if(coinflip == 'heads'){
coinflip <- rank(tab$team)
print('In case of ties, larger team number gets higher rank.')
}else {
coinflip <- -rank(tab$team)
print('In case of ties, lower team number gets higher rank.')
}
wpb <- dat[[wpb]]
pb <- dat[[pb]]
pd <- dat[[pd]]
wpb[is.na(wpb)] <- 0
pb[is.na(pb)] <- 0
pd[is.na(pd)] <- 0
return(rank(-1*as.numeric(
interaction(wpb, pb, pd, coinflip,
drop = TRUE, lex.order = TRUE))))
}
# Calculate distance by WPB, PB, PD
# Returns
compareDist <- function(x = trial_x, all = pair, round = round, amta = F){
# Minor Cleaning
all[is.na(all)] <- 0
x[is.na(x)] <- 0
# Create temporary ranking (after adjustments for impermissibles)
all <- all[order(all$trial, all$side), ]
if(round %% 2 == 0){
all <- ddply(all, .(side), mutate, newRank = rank(trial))
} else {
all$newRank <- 1:nrow(all)
}
x <- merge(x, all[, c('team', 'side', 'newRank')])
# Create all possible matches
calcDist <- function(x, all, sideT, roundNum = round){
x <- subset(x, side == sideT)
if(roundNum %% 2 == 0){
all <- subset(all, side == sideT)
}
if(sideT == 'D'){
cat <-  'Keep P, Swap D'
} else {
cat <- 'Keep D, Swap P'
}
return(
data.frame(
dist_wpb = abs(all$wpb - x$wpb),
dist_pb = abs(all$pb - x$pb),
dist_pd = abs(all$pd - x$pd),
dist_rank = abs(all$newRank - x$newRank),
cat = cat
)
)
}
if(round %% 2 == 0){ # If round is side-constrained
# Compare against teams of the same side
dSwap <- data.frame(p = x$team[x$side == 'P'],
d = all$team[all$side == 'D'])
dSwap <- cbind(dSwap, calcDist(x = x, all = all, sideT = 'D'))
pSwap <- data.frame(p = all$team[all$side == 'P'],
d = x$team[x$side == 'D'])
pSwap <- cbind(pSwap, calcDist(x = x, all = all, sideT = 'P'))
} else {
# Compare against all teams
dSwap <- data.frame(p = x$team[x$side == 'D'],
d = all$team)
dSwap <- cbind(dSwap, calcDist(x = x, all = all, sideT = 'D'))
pSwap <- data.frame(p = all$team,
d = x$team[x$side == 'D'])
pSwap <- cbind(pSwap, calcDist(x = x, all = all, sideT = 'P'))
}
res <- unique(rbind(dSwap, pSwap))
# Get rid of factors
i <- sapply(res, is.factor)
res[i] <- lapply(res[i], as.character)
# Get rid of matches where you're swapping the original ones,
# or where you're matching against the same team.
res <- subset(res, p != d)
res <- subset(res, !paste0(res$p, res$d) %in% c(paste0(x$team, collapse =''),
paste0(rev(x$team), collapse = '')))
# Sort by distance
res <- res[order(res$dist_rank, res$dist_wpb, res$dist_pb, res$dist_pd), ]
res <- subset(res, dist_rank > 0) # This is the no-swap option
return(res)
}
# Function to add metadata after pairing
teamMeta <- function(pair, input, side, round){
pair[[paste0(side, '_team')]] <- as.character(input[, 1])
pair[[paste0(side, '_WPB')]] <- as.numeric(input[, 3])
pair[[paste0(side, '_pb')]] <- as.numeric(input[, 4])
pair[[paste0(side, '_pd')]] <- as.numeric(input[, 5])
if(round %% 2 == 0){
pair[[paste0(side, '_rank')]] <- 1:nrow(pair)
} else {
pair[[paste0(side, '_rank')]] <- as.numeric(input[, 6])
}
return(pair)
}
# Find Impermissibles
findImpermiss <- function(dat = pair, impermissibles = impermiss){
notOkay <- paste0(impermissibles[, 1], impermissibles[, 2])
res <- rep(F, nrow(dat))
for(i in 1:nrow(dat)){
proposedPair <- paste(pair$team[pair$trial == pair$trial[i]], collapse = '')
if(proposedPair %in% notOkay){
res[i] <- T
}
}
return(res)
}
# Make proposed swap
makeSwap <- function(newSwap = proposedSwap, old = trial_x, dat = pair){
swap <- function(swapSide = 'P', dat = dat){
# Get row numbers
oldD <- which(dat$team == old$team[old$side == swapSide])
newD <- which(dat$team == newSwap[[tolower(swapSide)]])
#writeLines('\nOriginal values\n')
#printTab(xtable(dat[c(oldD, newD), ]))
# Make the swap
oldTrial <- dat$trial[oldD]
oldSide <- dat$side[oldD]
newTrial <- dat$trial[newD]
newSide <- dat$side[newD]
dat$trial[c(oldD, newD)] <- c(newTrial, oldTrial)
dat$side[c(oldD, newD)] <- c(newSide, oldSide)
#writeLines('\nNew values\n')
#printTab(xtable(dat[c(oldD, newD), ]))
return(dat)
}
if(newSwap$cat == 'Keep D, Swap P'){
#writeLines(paste('\nSwapping Pros team', old$P_team, 'for', newSwap$p))
side = 'P'
} else {
#writeLines(paste('\nSwapping Def team', old$D_team, 'for', newSwap$d))
side = 'D'
}
return(swap(swapSide = side, dat = dat))
}
# Generate Swap
swapList <- function(newSwap = proposedSwap, oldSwap = trial_x){
if(newSwap$cat == 'Keep P, Swap D'){
neW <- c(team1 = newSwap$d,
team2 = trial_x$team[trial_x$side == 'D'])
} else {
neW <- c(team1 = newSwap$p,
team2 = trial_x$team[trial_x$side == 'P'])
}
return(neW)
}
# Insert Swaps
insertSwap <- function(newSwap = proposedSwap, oldSwap = trial_x, dat = swaps){
x <- swapList(newSwap = proposedSwap, oldSwap = trial_x)
# Create out combinations
news <- data.frame(Team1 = x,
Team2 = rev(x),
final = NA,
stringsAsFactors = F)
# Add to existing
dat <- rbind(dat, news)
# Get rid of NAs
dat <- subset(dat, !is.na(Team1))
# Create concatenation
dat$final <- apply(dat, 1, function(x){
paste0(x[1], x[2])
})
return(dat)
}
library(XML)
compareDist(x = trial_x, all = pair, round = round, amta = F)
head(pair)
