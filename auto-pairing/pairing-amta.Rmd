---
title: "Round Pairing"
author: "ajw"
output:
  html_document:
    css: markdown7.css
---

# Set-up
Set the round that you are pairing.
```{r}
round <- 3
amta <- T
```

This runs the backing functions, which can be found [here](https://gist.github.com/anniejw6/9cb2d782eb9b7758a653).
```{r,warning = F, message = F}
source('pair_func.R')
```

Read in data from google sheets.
```{r}
teams <- 'https://docs.google.com/spreadsheets/d/1CU4WO8heN0LBXSURLOZQXopt0UV480Cmg7h8NuBXcRY/pubhtml?gid=0&single=true'
tab   <- 'https://docs.google.com/spreadsheets/d/1CU4WO8heN0LBXSURLOZQXopt0UV480Cmg7h8NuBXcRY/pubhtml?gid=2080568749&single=true'

teams <- readSpreadsheet(teams)
df <- cleanTab(readSpreadsheet(tab))

tab <- data.frame(
  team = df$TEAM,
  side = df[[paste0('R', round - 1, '_SIDE')]],
  bal  = as.numeric(df[[paste0('R', round - 1, '_RT_BAL')]]),
  cs   = as.numeric(df[[paste0('R', round - 1, '_RT_CS')]]),
  pd   = as.numeric(df[[paste0('R', round - 1, '_RT_PD')]]),
  stringsAsFactors = F
)

tab$rank <- rankWPB(wpb = 'bal',
                    pb  = 'cs',
                    pd  = 'pd', dat = tab, r = round)
```

`teams` lists out past pairings, which are used to check impermissibles.
```{r, echo = F, results='asis'}
printTab(xtable(head(teams)))
```

`tab` shows the values on which we pair.
```{r, echo = F, results='asis'}
printTab(xtable(head(tab)))
```

# Defining Impermissibles
We store a list of impermissible match-ups, which are 
defined either as teams from the same school or teams that have previously faced one another.
Here's a sample of that list.
```{r, echo = F, results='asis'}
impermiss <- rbind(sameSchool(teams),
                   pastOpp(df, round))
printTab(xtable(head(impermiss)))
```

# Pairing

Now we pair the teams. If the round is side-constrained, we rank and pair by sides. Otherwise, we take all the teams togther.
```{r}
pair <- data.frame(P_team = rep(NA, nrow(df)/2),
                   D_team = NA)

#if round is side-constrained:
if(round %in% c(2,4)){
  
  #rank sides separately
  needP <- tab[tab$side == 'D', ]
  needD <- tab[tab$side == 'P', ]
  
  #pair highest versus highest
  pair <- teamMeta(pair, needP[order(needP$rank), ], side = 'P', round = round)
  pair <- teamMeta(pair, needD[order(needD$rank), ], side = 'D', round = round)
  
} else {
  
  #rank teams together
  tab <- tab[order(tab$rank), ]
  
  #pair 1 vs 2, 3 vs 4, etc
  pair <- teamMeta(pair, tab[c(T, F), ], side = 'P', round = round)
  pair <- teamMeta(pair, tab[c(F, T), ], side = 'D', round = round)
  
}
```

Here's the pairings, which may or may not include impermissibles.
```{r, echo = F, results='asis'}
printTab(xtable(pair))
```

# Finding and Resolving Impermissibles

We loop through each row and see whether 
the matchup is in the list of impermissibles we created earlier.
```{r, echo = T, results='asis'}
# Find impermissibles
pair$impermiss <- findImpermiss(pair, impermiss)

# Set value to store swaps
swaps <- data.frame(Team1 = NA, Team2 = NA, final = NA)
```

And then we actually try to resolve them.
```{r impermiss, results = 'asis'}
# If there are no impermissibles,
if(sum(pair$impermiss) == 0){
  
  writeLines('No impermissibles!')
  
} else {
  
  # resolve impermissibles
  while (sum(pair$impermiss) > 0){
  
    # Print pairings at start
    writeLines('Current List of Pairings')
    printTab(xtable(addColor(pair)))
    
    # set trial_x = highest trial with impermissible
    trial_x <- pair[min(which(pair$impermiss == T)), ]
    
    # Compare swap distances based on WPB, PB, and PD
    possSwaps <- compareDist(all = tab, x = trial_x, pair = pair, round = round, amta = amta)  
    
    repeat{
      
      # Set proposed_swap = minimum distance swap
      proposedSwap <- possSwaps[1, ]
      
      # proposed Swap
      writeLines('Proposed Swap')
      printTab(xtable(proposedSwap))
      
      # If it's allowed
      if(!paste0(proposedSwap$p, proposedSwap$d) %in% swaps$final){
        break # Move on
      }
      
      # If it's not allowed, remove proposed_swap from possible
      writeLines('Proposed swap is not possible!')
      possSwaps <- possSwaps[-1, ]
    }
    
    #  make proposed_swap
    pair <- makeSwap(newSwap = proposedSwap, old = trial_x, dat = pair)
    
    #  insert proposed_swap in SWAP
    swaps <- insertSwap(neW = proposedSwap, dat = swaps)
    
    #  set n = number of impermissibles
    pair$impermiss <- findImpermiss(pair, impermiss)
    }
  }
```

# Final Pairings

Here are final pairings, which are resolved for impermissibles.
```{r, echo = F, results = 'asis'}
printTab(xtable(addColor(pair)))
```

